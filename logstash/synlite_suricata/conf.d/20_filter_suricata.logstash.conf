#------------------------------------------------------------------------------
# Copyright (C)2018 Robert Cowart
# 
# The contents of this file and/or repository are subject to the Robert Cowart
# Public License (the "License") and may not be used or distributed except in
# compliance with the License. You may obtain a copy of the License at:
# 
# http://www.koiossian.com/public/robert_cowart_public_license.txt
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Source Code was developed by Robert Cowart. Portions created by
# Robert Cowart are Copyright (C)2018 Robert Cowart. All Rights Reserved.
#------------------------------------------------------------------------------

filter {
  if [fields][event][type] == "suricata" {
    # Initial handling of raw  message.
      mutate {
        add_field => {
          "[@metadata][resolve_ip2host]" => "${SYNLITE_SURICATA_RESOLVE_IP2HOST:false}"
          "[@metadata][geoip_lookup]" => "${SYNLITE_SURICATA_GEOIP_LOOKUP:true}"
          "[@metadata][asn_lookup]" => "${SYNLITE_SURICATA_ASN_LOOKUP:true}"
          "[@metadata][cleanup_sigs]" => "${SYNLITE_SURICATA_CLEANUP_SIGS:false}"
        }
        rename => {
          "[fields][event][type]" => "[event][type]"
          "[agent][hostname]" => "[event][host]"
        }
        remove_field => [ "prospector", "source" ]
        remove_tag => [ "beats_input_codec_plain_applied" ]
        replace => {
          "@version" => "1.1.0"
        }
      }

      if [@metadata][ip_address] {
        mutate {
          add_field => { "[node][ipaddr]" => "%{[@metadata][ip_address]}" }
        }
      }
      if [host][name] {
        mutate {
          rename => { "[host][name]" => "[node][hostname]" }
        }
      }

      mutate {
        remove_field => [ "agent", "beat", "ecs", "input", "fields", "log", "offset" ]
      }

    # Parse JSON
      json {
        skip_on_invalid_json => true
        source => "message"
      }

    # Process parsed JSON data.
      if "_jsonparsefailure" not in [tags] {
        # Cleanup unneeded fields.
          mutate {
            remove_field => [ "type", "message" ]
          }

        # Set @timestamp
          if [timestamp] {
            # 2018-05-28T22:54:43.665709+0000
            date {
              match => [ "[timestamp]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
              remove_field => [ "[timestamp]" ]
            }
          }
        
        # Set event.subtype
          if [event_type] {
            mutate {
              rename => { "[event_type]" => "[event][subtype]" }
            }
          }

          if ![event][subtype] and [alert][signature_id] {
            mutate {
              add_field => { "[event][subtype]" => "alert" }
            }
          }

        # Handle event-specific fields.
        if [event][subtype] != "stats" {
          # Convert date fields if present.
            if [flow][end] {
              date {
                match => [ "[flow][end]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[flow][end]" ]
              }
            }
            if [flow][start] {
              date {
                match => [ "[flow][start]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[flow][start]" ]
              }
            }
            if [tls][notafter] {
              date {
                match => [ "[tls][notafter]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notafter]" ]
              }
            }
            if [tls][notbefore] {
              date {
                match => [ "[tls][notbefore]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notbefore]" ]
              }
            }

          # Determine IP Version with CIDR checks.
            if [src_ip] {
              cidr {
                address => [ "%{[src_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  address => [ "%{[src_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            } else if [dest_ip] {
              cidr {
                address => [ "%{[dest_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  address => [ "%{[dest_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            }
          
          # Compress IPv6 addresses.
            if [ip_version] == "IPv6" {
              if [src_ip] {
                ruby {
                  init => "
                    require 'ipaddr'
                  "
                  code => "
                    ip6addr = IPAddr.new(event.get('[src_ip]'))
                    event.set('[src_ip]', ip6addr.to_s)
                  "
                }
              }
              if [dest_ip] {
                ruby {
                  init => "
                    require 'ipaddr'
                  "
                  code => "
                    ip6addr = IPAddr.new(event.get('[dest_ip]'))
                    event.set('[dest_ip]', ip6addr.to_s)
                  "
                }
              }
            }
            
          # If enabled, resolve names of source and destination IP addresses.
            if [dest_ip] {
              # If localhost then use the IP from the host field.
              if [dest_ip] == "127.0.0.1" {
                mutate {
                  replace => { "[dest_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  add_field => { "[dest_hostname]" => "%{[dest_ip]}"}
                }
              }
              # Resolve destination IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  reverse => [ "[dest_hostname]" ]
                  action => "replace"
                  nameserver => "${SYNLITE_SURICATA_NAMESERVER:127.0.0.1}"
                  hit_cache_size => "${SYNLITE_SURICATA_DNS_HIT_CACHE_SIZE:25000}"
                  hit_cache_ttl => "${SYNLITE_SURICATA_DNS_HIT_CACHE_TTL:900}"
                  failed_cache_size => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_SIZE:75000}"
                  failed_cache_ttl => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_TTL:3600}"
                }
              }
            }

            if [src_ip] {
              # If localhost then use the IP from the host field.
              if [src_ip] == "127.0.0.1" {
                mutate {
                  replace => { "[src_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  add_field => { "[src_hostname]" => "%{[src_ip]}"}
                }
              }
              # Resolve source IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  reverse => [ "[src_hostname]" ]
                  action => "replace"
                  nameserver => "${SYNLITE_SURICATA_NAMESERVER:127.0.0.1}"
                  hit_cache_size => "${SYNLITE_SURICATA_DNS_HIT_CACHE_SIZE:25000}"
                  hit_cache_ttl => "${SYNLITE_SURICATA_DNS_HIT_CACHE_TTL:900}"
                  failed_cache_size => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_SIZE:75000}"
                  failed_cache_ttl => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_TTL:3600}"
                }
              }
            }

          # Determine the locality of the traffic and lookup GeoIP, ASN and IP Reputation information.
            if [dest_ip] or [src_ip] {
              # Initialize traffic_locality to private. This maybe changed to public based on analysis of the source and destination IP addresses below.
              mutate {
                add_field => { "[traffic_locality]" => "private" }
              }

              if [dest_ip] {
                # Check if destination IP address is private.
                  cidr {
                    address => [ "%{[dest_ip]}" ]
                    network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128","169.254.0.0/16", "fe80::/10","224.0.0.0/4", "ff00::/8","255.255.255.255/32" ]
                    add_field => { "[dest_autonomous_system]" => "private" }
                  }

                # Check to see if dest_autonomous_system exists. If it doesn't the dest_ip didn't match a private address space and must be public.
                  if ![dest_autonomous_system] {
                    mutate {
                      replace => { "[traffic_locality]" => "public" }
                    }

                    # If enabled lookup destination GeoIP location.
                      if [@metadata][geoip_lookup] == "true" {
                        geoip {
                          source => "[dest_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-City.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_dest]"
                          fields => [ "city_name", "country_name", "location" ]
                        }
                        if "_geoip_lookup_failure" not in [tags] {
                          mutate {
                            rename => {
                              "[metadata][geoip_dest][city_name]" => "[dest_city]"
                              "[metadata][geoip_dest][country_name]" => "[dest_country]"
                              "[metadata][geoip_dest][location]" => "[dest_geo_location]"
                            }
                          }
                          if [dest_city] {
                            mutate {
                              add_field => { "[city]" => "%{[dest_city]}" }
                            }
                          }
                          if [dest_country] {
                            mutate {
                              add_field => { "[country]" => "%{[dest_country]}" }
                            }
                          }
                        } else {
                          mutate {
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      }

                    # If enabled lookup destination Autonomous System.
                      if [@metadata][asn_lookup] == "true" {
                        # Lookup destination Autonomous System.
                        geoip {
                          source => "[dest_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-ASN.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_dest]"
                        }
                        # Populate dest_autonomous_system.
                        if "_geoip_lookup_failure" not in [tags] {
                          if [metadata][geoip_dest][as_org] {
                            if [metadata][geoip_dest][asn] {
                              mutate {
                                add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][as_org]} (%{[metadata][geoip_dest][asn]})" }
                              }
                            } else {
                              mutate {
                                add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][as_org]}" }
                              }
                            }
                          } else if [metadata][geoip_dest][asn] {
                            mutate {
                              add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][asn]}" }
                            }
                          } else {
                            mutate {
                              add_field => { "[dest_autonomous_system]" => "public" }
                            }
                          }
                          mutate {
                            rename => { "[metadata][geoip_dest][asn]" => "[dest_asn]" }
                          }
                        } else {
                          mutate {
                            add_field => { "[dest_autonomous_system]" => "public" }
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      } else {
                        mutate {
                          add_field => { "[dest_autonomous_system]" => "public" }
                        }
                      }
                      mutate {
                        add_field => {
                          "[autonomous_system]" => "%{[dest_autonomous_system]}"
                        }
                      }

                    # Lookup destination IP reputation.
                      translate {
                        dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/ip_rep_basic.yml"
                        field => "[dest_ip]"
                        destination => "[@metadata][dest_rep_label]"
                      }
                      # Parse the IP reputation lable into tags.
                      if [@metadata][dest_rep_label] {
                        ruby {
                          init => "
                            require 'csv'
                          "
                          code => "
                            event.set('[dest_rep_tags]', event.get('[@metadata][dest_rep_label]').parse_csv)
                          "
                        }
                      }
                  }
              }

              if [src_ip] {
                # Check if source IP address is private.
                  cidr {
                    address => [ "%{[src_ip]}" ]
                    network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
                    add_field => { "[src_autonomous_system]" => "private" }
                  }

                # Check to see if src_autonomous_system exists. If it doesn't the src_ip didn't match a private address space and locality must be public.
                  if ![src_autonomous_system] {
                    mutate {
                      replace => { "[traffic_locality]" => "public" }
                    }

                    # If enabled lookup source GeoIP location.
                      if [@metadata][geoip_lookup] == "true" {
                        geoip {
                          source => "[src_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-City.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_src]"
                          fields => [ "city_name", "country_name", "location" ]
                        }
                        if "_geoip_lookup_failure" not in [tags] {
                          mutate {
                            rename => {
                              "[metadata][geoip_src][city_name]" => "[src_city]"
                              "[metadata][geoip_src][country_name]" => "[src_country]"
                              "[metadata][geoip_src][location]" => "[src_geo_location]"
                            }
                          }
                          if [src_city] {
                            mutate {
                              add_field => { "[city]" => "%{[src_city]}" }
                            }
                          }
                          if [src_country] {
                            mutate {
                              add_field => { "[country]" => "%{[src_country]}" }
                            }
                          }
                        }
                      }

                    # If enabled lookup the source Autonomous System.
                      if [@metadata][asn_lookup] == "true" {
                        geoip {
                          source => "[src_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-ASN.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_src]"
                        }
                        # Populate src_autonomous_system.
                        if "_geoip_lookup_failure" not in [tags] {
                          if [metadata][geoip_src][as_org] {
                            if [metadata][geoip_src][asn] {
                              mutate {
                                add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][as_org]} (%{[metadata][geoip_src][asn]})" }
                              }
                            } else {
                              mutate {
                                add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][as_org]}" }
                              }
                            }
                          } else if [metadata][geoip_src][asn] {
                            mutate {
                              add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][asn]}" }
                            }
                          } else {
                            mutate {
                              add_field => { "[src_autonomous_system]" => "public" }
                            }
                          }
                          mutate {
                            rename => { "[metadata][geoip_src][asn]" => "[src_asn]" }
                          }
                        } else {
                          mutate {
                            add_field => { "[src_autonomous_system]" => "public" }
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      } else {
                        mutate {
                          add_field => { "[src_autonomous_system]" => "public" }
                        }
                      }
                      mutate {
                        add_field => {
                          "[autonomous_system]" => "%{[src_autonomous_system]}"
                        }
                      }
                    
                    # Lookup source IP reputation.
                      translate {
                        dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/ip_rep_basic.yml"
                        field => "[src_ip]"
                        destination => "[@metadata][src_rep_label]"
                      }
                      # Parse the IP reputation lable into tags.
                      if [@metadata][src_rep_label] {
                        ruby {
                          init => "
                            require 'csv'
                          "
                          code => "
                            event.set('[src_rep_tags]', event.get('[@metadata][src_rep_label]').parse_csv)
                          "
                        }
                      }
                  }
              }

              # Cleanup any GeoIP lookup failure tag.
                if "_geoip_lookup_failure" in [tags] {
                  mutate {
                    remove_tag => [ "_geoip_lookup_failure" ]
                  }
                }

              # Merge reputation tags.
                ruby {
                  init => "
                    require 'csv'
                  "
                  code => "
                    src_tags = event.get('[@metadata][src_rep_label]')
                    dest_tags = event.get('[@metadata][dest_rep_label]')

                    if (src_tags)
                      rep_tags = src_tags
                      if (dest_tags)
                        rep_tags = rep_tags << ',' << dest_tags
                      end
                    else (dest_tags)
                      rep_tags = dest_tags
                    end

                    if (rep_tags)
                      event.set('[rep_tags]', rep_tags.parse_csv )
                    end
                  "
                }
            }
          
          # IP traffic processing.
            if [proto] {
              # lookup IANA service name for source and destination ports.
                if [proto] == "TCP" {
                  if [src_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_tcp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_tcp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "UDP" {
                  if [src_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_udp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_udp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "SCTP" {
                  if [src_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_sctp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_sctp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "DCCP" {
                  if [src_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_dccp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_dccp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else {
                  mutate {
                    add_field => {
                      "[src_port_name]" => "__UNKNOWN"
                      "[dest_port_name]" => "__UNKNOWN"
                    }
                  }
                }

              # Ensure port numbers are integers.
                mutate {
                  convert => {
                    "[src_port]" => "integer"
                    "[dest_port]" => "integer"
                  }
                }

              # Determine client and server from source and destination ports.
                if [dest_port] and [src_port] {
                  if [src_port_name] == "__UNKNOWN" {
                    if [dest_port_name] == "__UNKNOWN" {
                      if [dest_port] <= [src_port] {
                        mutate {
                          add_field => { "[@metadata][isServer]" => "dest" }
                        }
                      } else {
                        mutate {
                          add_field => { "[@metadata][isServer]" => "src" }
                        }
                      }
                    } else {
                      mutate {
                        add_field => { "[@metadata][isServer]" => "dest" }
                      }
                    }
                  } else {
                    if [dest_port_name] == "__UNKNOWN" {
                      mutate {
                        add_field => { "[@metadata][isServer]" => "src" }
                      }
                    } else {
                      if [dest_port] <= [src_port] {
                        mutate {
                          add_field => { "[@metadata][isServer]" => "dest" }
                        }
                      } else {
                        mutate {
                          add_field => { "[@metadata][isServer]" => "src" }
                        }
                      }
                    }
                  }
                }

              # Set final value of port name fields.
                if [src_port_name] {
                  if [src_port_name] == "__UNKNOWN" {
                    if [src_port] {
                      mutate {
                        replace => { "[src_port_name]" => "%{[proto]}/%{[src_port]}" }
                      }
                    } else {
                      mutate {
                        replace => { "[src_port_name]" => "%{[proto]}/0" }
                      }
                    }
                  } else {
                    mutate {
                      replace => { "[src_port_name]" => "%{[src_port_name]} (%{[proto]}/%{[src_port]})" }
                    }
                  }
                }
                if [dest_port_name] {
                  if [dest_port_name] == "__UNKNOWN" {
                    if [dest_port] {
                      mutate {
                        replace => { "[dest_port_name]" => "%{[proto]}/%{[dest_port]}" }
                      }
                    } else {
                      mutate {
                        replace => { "[dest_port_name]" => "%{[proto]}/0" }
                      }
                    }
                  } else {
                    mutate {
                      replace => { "[dest_port_name]" => "%{[dest_port_name]} (%{[proto]}/%{[dest_port]})" }
                    }
                  }
                }

              # Set client, server and service fields.
                if [@metadata][isServer] == "dest" {
                  mutate {
                    add_field => {
                      "[server_ip]" => "%{[dest_ip]}"
                      "[server_hostname]" => "%{[dest_hostname]}"
                      "[server_autonomous_system]" => "%{[dest_autonomous_system]}"
                      "[service_port]" => "%{[dest_port]}"
                      "[service_name]" => "%{[dest_port_name]}"
                      "[client_ip]" => "%{[src_ip]}"
                      "[client_hostname]" => "%{[src_hostname]}"
                      "[client_autonomous_system]" => "%{[src_autonomous_system]}"
                    }
                  }
                  if [dest_autonomous_system] != "private" {
                    if [dest_city] {
                      mutate {
                        add_field => { "[server_city]" => "%{[dest_city]}" }
                      }
                    }
                    if [dest_country] {
                      mutate {
                        add_field => { "[server_country]" => "%{[dest_country]}" }
                      }
                    }
                    if [dest_geo_location] {
                      mutate {
                        add_field => { "[server_geo_location]" => "%{[dest_geo_location][lat]},%{[dest_geo_location][lon]}" }
                      }
                    }
                    if [dest_asn] {
                      mutate {
                        add_field => { "[server_asn]" => "%{[dest_asn]}" }
                      }
                    }
                  }
                  if [src_autonomous_system] != "private" {
                    if [src_city] {
                      mutate {
                        add_field => { "[client_city]" => "%{[src_city]}" }
                      }
                    }
                    if [src_country] {
                      mutate {
                        add_field => { "[client_country]" => "%{[src_country]}" }
                      }
                    }
                    if [src_geo_location] {
                      mutate {
                        add_field => { "[client_geo_location]" => "%{[src_geo_location][lat]},%{[src_geo_location][lon]}" }
                      }
                    }
                    if [src_asn] {
                      mutate {
                        add_field => { "[client_asn]" => "%{[src_asn]}" }
                      }
                    }
                  }
                } else if [@metadata][isServer] == "src" {
                  mutate {
                    add_field => {
                      "[server_ip]" => "%{[src_ip]}"
                      "[server_hostname]" => "%{[src_hostname]}"
                      "[server_autonomous_system]" => "%{[src_autonomous_system]}"
                      "[service_port]" => "%{[src_port]}"
                      "[service_name]" => "%{[src_port_name]}"
                      "[client_ip]" => "%{[dest_ip]}"
                      "[client_hostname]" => "%{[dest_hostname]}"
                      "[client_autonomous_system]" => "%{[dest_autonomous_system]}"
                    }
                  }
                  if [dest_autonomous_system] != "private" {
                    if [dest_city] {
                      mutate {
                        add_field => { "[client_city]" => "%{[dest_city]}" }
                      }
                    }
                    if [dest_country] {
                      mutate {
                        add_field => { "[client_country]" => "%{[dest_country]}" }
                      }
                    }
                    if [dest_geo_location] {
                      mutate {
                        add_field => { "[client_geo_location]" => "%{[dest_geo_location][lat]},%{[dest_geo_location][lon]}" }
                      }
                    }
                    if [dest_asn] {
                      mutate {
                        add_field => { "[client_asn]" => "%{[dest_asn]}" }
                      }
                    }
                  }
                  if [src_autonomous_system] != "private" {
                    if [src_city] {
                      mutate {
                        add_field => { "[server_city]" => "%{[src_city]}" }
                      }
                    }
                    if [src_country] {
                      mutate {
                        add_field => { "[server_country]" => "%{[src_country]}" }
                      }
                    }
                    if [src_geo_location] {
                      mutate {
                        add_field => { "[server_geo_location]" => "%{[src_geo_location][lat]},%{[src_geo_location][lon]}" }
                      }
                    }
                    if [src_asn] {
                      mutate {
                        add_field => { "[server_asn]" => "%{[src_asn]}" }
                      }
                    }
                  }
                }
            }

          # Populate flow.bytes
            if [flow][bytes_toclient] {
              if [flow][bytes_toserver] {
                ruby {
                  code => "
                    event.set( '[flow][bytes]', event.get('[flow][bytes_toclient]').to_i + event.get('[flow][bytes_toserver]').to_i )
                  "
                }
              } else {
                mutate {
                  rename => { "[flow][bytes]" => "%{[flow][bytes_toclient]}" }
                }
              }
            } else if [flow][bytes_toserver] {
              mutate {
                rename => { "[flow][bytes]" => "%{[flow][bytes_toserver]}" }
              }
            }
            if [flow][bytes] {
              mutate {
                convert => { "[flow][bytes]" => "integer" }
              }
            }

          # Populate flow.pkts
            if [flow][pkts_toclient] {
              if [flow][pkts_toserver] {
                ruby {
                  code => "
                    event.set( '[flow][pkts]', event.get('[flow][pkts_toclient]').to_i + event.get('[flow][pkts_toserver]').to_i )
                  "
                }
              } else {
                mutate {
                  rename => { "[flow][pkts]" => "%{[flow][pkts_toclient]}" }
                }
              }
            } else if [flow][pkts_toserver] {
              mutate {
                rename => { "[flow][pkts]" => "%{[flow][pkts_toserver]}" }
              }
            }
            if [flow][pkts] {
              mutate {
                convert => { "[flow][pkts]" => "integer" }
              }
            }

          # Set VLAN to 0 if not present.
            if ![vlan] {
              if [src_ip] and [dest_ip] {
                mutate {
                  add_field => { "vlan" => "0" }
                }
              }
            }
          
          # Simplify smb.status
            if [smb][status] {
              mutate {
                gsub => [ "[smb][status]", "STATUS_", "" ]
              }
            }

          # Process TCP flags.
            if [tcp][tcp_flags] {
              if [tcp][ack] {
                mutate {
                  add_field => { "[tcp_flags]" => "ACK" }
                }
              }
              if [tcp][cwr] {
                mutate {
                  add_field => { "[tcp_flags]" => "CWR" }
                }
              }
              if [tcp][ece] {
                mutate {
                  add_field => { "[tcp_flags]" => "ECE" }
                }
              }
              if [tcp][fin] {
                mutate {
                  add_field => { "[tcp_flags]" => "FIN" }
                }
              }
              if [tcp][psh] {
                mutate {
                  add_field => { "[tcp_flags]" => "PSH" }
                }
              }
              if [tcp][rst] {
                mutate {
                  add_field => { "[tcp_flags]" => "RST" }
                }
              }
              if [tcp][syn] {
                mutate {
                  add_field => { "[tcp_flags]" => "SYN" }
                }
              }
              if [tcp][urg] {
                mutate {
                  add_field => { "[tcp_flags]" => "URG" }
                }
              }

              mutate {
                remove_field => [ "[tcp][ack]", "[tcp][cwr]", "[tcp][ece]", "[tcp][fin]", "[tcp][psh]", "[tcp][rst]", "[tcp][syn]", "[tcp][urg]" ]
              }
            } else {
              mutate {
                replace => { "[tcp_flags]" => "none" }
              }
            }

          # Translate ICMP Types and Codes to text.
            if [icmp_type] {
              if [icmp_code] {
                mutate {
                  replace => { "[@metadata][icmp_key]" => "%{[icmp_type]}..%{[icmp_code]}" }
                }

                if [ip_version] == "IPv6" {
                  translate {
                    dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmpv6_code.yml"
                    field => "[@metadata][icmp_key]"
                    destination => "[icmp_code]"
                    override => "true"
                    fallback => "unspecified (%{[icmp_code]})"
                    refresh_behaviour => "replace"
                  }
                } else {
                  translate {
                    dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmp_code.yml"
                    field => "[@metadata][icmp_key]"
                    destination => "[icmp_code]"
                    override => "true"
                    fallback => "unspecified (%{[icmp_code]})"
                    refresh_behaviour => "replace"
                  }
                }
              }

              if [ip_version] == "IPv6" {
                translate {
                  dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmpv6_type.yml"
                  field => "[icmp_type]"
                  destination => "[icmp_type]"
                  override => "true"
                  fallback => "unspecified (%{[icmp_type]})"
                  refresh_behaviour => "replace"
                }
              } else {
                translate {
                  dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmp_type.yml"
                  field => "[icmp_type]"
                  destination => "[icmp_type]"
                  override => "true"
                  fallback => "unspecified (%{[icmp_type]})"
                  refresh_behaviour => "replace"
                }
              }
            }

            if [response_icmp_type] {
              if [response_icmp_code] {
                mutate {
                  replace => { "[@metadata][icmp_key]" => "%{[response_icmp_type]}..%{[response_icmp_code]}" }
                }

                if [ip_version] == "IPv6" {
                  translate {
                    dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmpv6_code.yml"
                    field => "[@metadata][icmp_key]"
                    destination => "[response_icmp_code]"
                    override => "true"
                    fallback => "unspecified (%{[response_icmp_code]})"
                    refresh_behaviour => "replace"
                  }
                } else {
                  translate {
                    dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmp_code.yml"
                    field => "[@metadata][icmp_key]"
                    destination => "[response_icmp_code]"
                    override => "true"
                    fallback => "unspecified (%{[response_icmp_code]})"
                    refresh_behaviour => "replace"
                  }
                }
              }

              if [ip_version] == "IPv6" {
                translate {
                  dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmpv6_type.yml"
                  field => "[response_icmp_type]"
                  destination => "[response_icmp_type]"
                  override => "true"
                  fallback => "unspecified (%{[response_icmp_type]})"
                  refresh_behaviour => "replace"
                }
              } else {
                translate {
                  dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_icmp_type.yml"
                  field => "[response_icmp_type]"
                  destination => "[response_icmp_type]"
                  override => "true"
                  fallback => "unspecified (%{[response_icmp_type]})"
                  refresh_behaviour => "replace"
                }
              }
            }

          # Set log.severity
            if [alert][severity] {
              translate {
                field => "[alert][severity]"
                destination => "[log][severity]"
                dictionary => {
                  "1" => "alert"
                  "2" => "critical"
                  "3" => "warning"
                  "4" => "notice"
                }
                fallback => "warning"
              }
            } else {
              mutate {
                replace => { "[log][severity]" => "informational" }
              }
            }

          # Populate alert.cve.
            if [alert][signature_id] {
              translate {
                dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/suricata_cve.yml"
                field => "[alert][signature_id]"
                destination => "[alert][cve]"
              }
            }

          # Process the user agent.
            if [http][http_user_agent] {
              useragent {
                source => "[http][http_user_agent]"
                target => "[@metadata][useragent]"
                lru_cache_size => "2048"
              }

              # Construct http.useragent_app
              if [@metadata][useragent][name] {
                mutate {
                  add_field => { "[http][useragent_app]" => "%{[@metadata][useragent][name]}" }
                }
                if [@metadata][useragent][major] {
                  mutate {
                    add_field => { "[http][useragent_app_ver]" => "%{[@metadata][useragent][major]}" }
                  }
                  if [@metadata][useragent][minor] {
                    mutate {
                      replace => { "[http][useragent_app_ver]" => "%{[http][useragent_app_ver]}.%{[@metadata][useragent][minor]}" }
                    }
                    if [@metadata][useragent][patch] {
                      mutate {
                        replace => { "[http][useragent_app_ver]" => "%{[http][useragent_app_ver]}.%{[@metadata][useragent][patch]}" }
                      }
                    }
                  }
                }
              }

              # Construct http.useragent_os
              if [@metadata][useragent][os_name] {
                mutate {
                  add_field => { "[http][useragent_os]" => "%{[@metadata][useragent][os_name]}" }
                }
                if [@metadata][useragent][os_major] {
                  mutate {
                    add_field => { "[http][useragent_os_ver]" => "%{[@metadata][useragent][os_major]}" }
                  }
                  if [@metadata][useragent][minor] {
                    mutate {
                      replace => { "[http][useragent_os_ver]" => "%{[http][useragent_os_ver]}.%{[@metadata][useragent][os_minor]}" }
                    }
                  }
                }
              }

              # Construct conn.useragent_device
              if [@metadata][useragent][device] {
                mutate {
                  add_field => { "[http][useragent_device]" => "%{[@metadata][useragent][device]}" }
                }
              }
            }

          # Cleanup attack decriptions.
            if [@metadata][cleanup_sigs] == "true" {
              if [alert][signature] {
                if [alert][signature] =~ /^ET DELETED .*$/ {
                  mutate {
                    gsub => [ "[alert][signature]", "^ET DELETED ", "" ]
                  }
                } else if [alert][signature] =~ /^ET .*$/ {
                  mutate {
                    gsub => [ "[alert][signature]", "^ET ", "" ]
                  }
                } else if [alert][signature] =~ /^SURICATA .*$/ {
                  mutate {
                    gsub => [ "[alert][signature]", "^SURICATA ", "" ]
                  }
                } else if [alert][signature] =~ /^DELETED .*$/ {
                  mutate {
                    gsub => [ "[alert][signature]", "^DELETED ", "" ]
                  }
                } else if [alert][signature] =~ /^CURRENT_EVENTS(?: -)? .*$/ {
                  mutate {
                    gsub => [ "[alert][signature]", "^CURRENT_EVENTS(?: -)? ", "" ]
                  }
                }
              }
            }

          # Cleanup metadata object.
            mutate {
              remove_field => [ "[metadata]" ]
            }
        }
      }
  }
}
