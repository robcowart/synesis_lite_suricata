#------------------------------------------------------------------------------
# Copyright (C)2018 Robert Cowart
# 
# The contents of this file and/or repository are subject to the Robert Cowart
# Public License (the "License") and may not be used or distributed except in
# compliance with the License. You may obtain a copy of the License at:
# 
# http://www.koiossian.com/public/robert_cowart_public_license.txt
# 
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
# the specific language governing rights and limitations under the License.
# 
# The Original Source Code was developed by Robert Cowart. Portions created by
# Robert Cowart are Copyright (C)2018 Robert Cowart. All Rights Reserved.
#------------------------------------------------------------------------------

filter {
  if [fields][event][type] == "suricata" {
    # Initial handling of raw  message.
      mutate {
        add_field => {
          "[@metadata][resolve_ip2host]" => "${SYNLITE_SURICATA_RESOLVE_IP2HOST:false}"
          "[@metadata][geoip_lookup]" => "${SYNLITE_SURICATA_GEOIP_LOOKUP:true}"
          "[@metadata][asn_lookup]" => "${SYNLITE_SURICATA_ASN_LOOKUP:true}"
        }
        rename => {
          "[fields][event][type]" => "[event][type]"
          "[host]" => "[event][host]"
        }
        remove_field => [ "prospector", "source" ]
        remove_tag => [ "beats_input_codec_plain_applied" ]
        replace => {
          "@version" => "0.0.2"
        }
      }

      if [@metadata][ip_address] {
        mutate {
          add_field => { "[node][ipaddr]" => "%{[@metadata][ip_address]}" }
        }
      }
      if [beat][hostname] {
        mutate {
          rename => { "[beat][hostname]" => "[node][hostname]" }
        }
      }

      mutate {
        remove_field => [ "beat", "fields", "offset", "prospector", "source" ]
      }

    # Parse JSON
      json {
        skip_on_invalid_json => true
        source => "message"
      }

    # Process parsed JSON data.
      if "_jsonparsefailure" not in [tags] {
        # Cleanup unneeded fields.
          mutate {
            remove_field => [ "type", "message" ]
          }

        # Set @timestamp
          if [timestamp] {
            # 2018-05-28T22:54:43.665709+0000
            date {
              match => [ "[timestamp]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
              remove_field => [ "[timestamp]" ]
            }
          }
        
        # Set event.subtype
          if [event_type] {
            mutate {
              rename => { "[event_type]" => "[event][subtype]" }
            }
          }

        # Handle event-specific fields.
        if [event][subtype] != "stats" {
          # Convert date fields if present.
            if [end] {
              date {
                match => [ "[end]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[end]" ]
              }
            }
            if [start] {
              date {
                match => [ "[start]", "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
                target => [ "[start]" ]
              }
            }
            if [tls][notafter] {
              date {
                match => [ "[tls][notafter]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notafter]" ]
              }
            }
            if [tls][notbefore] {
              date {
                match => [ "[tls][notbefore]", "YYYY-MM-dd'T'HH:mm:ssZ" ]
                target => [ "[tls][notbefore]" ]
              }
            }

          # Determine IP Version with CIDR checks.
            if [src_ip] {
              cidr {
                id => "suricata_ipv4_cidr_src"
                address => [ "%{[src_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  id => "suricata_ipv6_cidr_src"
                  address => [ "%{[src_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            } else if [dest_ip] {
              cidr {
                id => "suricata_ipv4_cidr_dest"
                address => [ "%{[dest_ip]}" ]
                network => [ "0.0.0.0/0" ]
                add_field => {
                  "[ip_version]" => "IPv4"
                }
              }
              if ![ip_version] {
                cidr {
                  id => "suricata_ipv6_cidr_dest"
                  address => [ "%{[dest_ip]}" ]
                  network => [ "::/0" ]
                  add_field => {
                    "[ip_version]" => "IPv6"
                  }
                }
              }
            }
            
          # If enabled, resolve names of source and destination IP addresses.
            if [dest_ip] {
              # If localhost then use the IP from the host field.
              if [dest_ip] == "127.0.0.1" {
                mutate {
                  id => "suricata_dest_hostname_localhost"
                  replace => { "[dest_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  id => "suricata_dest_hostname_ip"
                  add_field => { "[dest_hostname]" => "%{[dest_ip]}"}
                }
              }
              # Resolve destination IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  id => "suricata_dns_dest_hostname"
                  reverse => [ "[dest_hostname]" ]
                  action => "replace"
                  nameserver => "${SYNLITE_SURICATA_NAMESERVER:127.0.0.1}"
                  hit_cache_size => "${SYNLITE_SURICATA_DNS_HIT_CACHE_SIZE:25000}"
                  hit_cache_ttl => "${SYNLITE_SURICATA_DNS_HIT_CACHE_TTL:900}"
                  failed_cache_size => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_SIZE:75000}"
                  failed_cache_ttl => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_TTL:3600}"
                }
              }
            }

            if [src_ip] {
              # If localhost then use the IP from the host field.
              if [src_ip] == "127.0.0.1" {
                mutate {
                  id => "suricata_src_hostname_localhost"
                  replace => { "[src_hostname]" => "%{[event][host]}" }
                }
              } else {
                mutate {
                  id => "suricata_src_hostname_ip"
                  add_field => { "[src_hostname]" => "%{[src_ip]}"}
                }
              }
              # Resolve source IP address to hostname.
              if [@metadata][resolve_ip2host] == "true" {
                dns {
                  id => "suricata_dns_src_hostname"
                  reverse => [ "[src_hostname]" ]
                  action => "replace"
                  nameserver => "${SYNLITE_SURICATA_NAMESERVER:127.0.0.1}"
                  hit_cache_size => "${SYNLITE_SURICATA_DNS_HIT_CACHE_SIZE:25000}"
                  hit_cache_ttl => "${SYNLITE_SURICATA_DNS_HIT_CACHE_TTL:900}"
                  failed_cache_size => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_SIZE:75000}"
                  failed_cache_ttl => "${SYNLITE_SURICATA_DNS_FAILED_CACHE_TTL:3600}"
                }
              }
            }

          # Determine the locality of the traffic and lookup GeoIP, ASN and IP Reputation information.
            if [dest_ip] or [src_ip] {
              # Initialize traffic_locality to private. This maybe changed to public based on analysis of the source and destination IP addresses below.
              mutate {
                id => "suricata_traffic_locality_default"
                add_field => { "[traffic_locality]" => "private" }
              }

              if [dest_ip] {
                # Check if destination IP address is private.
                  cidr {
                    id => "suricata_cidr_dest_ip"
                    address => [ "%{[dest_ip]}" ]
                    network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128","169.254.0.0/16", "fe80::/10","224.0.0.0/4", "ff00::/8","255.255.255.255/32" ]
                    add_field => { "[dest_autonomous_system]" => "private" }
                  }

                # Check to see if dest_autonomous_system exists. If it doesn't the dest_ip didn't match a private address space and must be public.
                  if ![dest_autonomous_system] {
                    mutate {
                      id => "suricata_dest_ip_public"
                      replace => { "[traffic_locality]" => "public" }
                    }

                    # If enabled lookup destination GeoIP location.
                      if [@metadata][geoip_lookup] == "true" {
                        geoip {
                          id => "suricata_geoip_dest_city"
                          source => "[dest_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-City.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_dest]"
                          fields => [ "city_name", "country_name", "location" ]
                        }
                        if "_geoip_lookup_failure" not in [tags] {
                          mutate {
                            rename => {
                              "[metadata][geoip_dest][city_name]" => "[dest_city]"
                              "[metadata][geoip_dest][country_name]" => "[dest_country]"
                              "[metadata][geoip_dest][location]" => "[dest_geo_location]"
                            }
                          }
                          if [dest_city] {
                            mutate {
                              add_field => { "[city]" => "%{[dest_city]}" }
                            }
                          }
                          if [dest_country] {
                            mutate {
                              add_field => { "[country]" => "%{[dest_country]}" }
                            }
                          }
                        } else {
                          mutate {
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      }

                    # If enabled lookup destination Autonomous System.
                      if [@metadata][asn_lookup] == "true" {
                        # Lookup destination Autonomous System.
                        geoip {
                          id => "suricata_geoip_dest_asn"
                          source => "[dest_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-ASN.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_dest]"
                        }
                        # Populate dest_autonomous_system.
                        if "_geoip_lookup_failure" not in [tags] {
                          if [metadata][geoip_dest][as_org] {
                            if [metadata][geoip_dest][asn] {
                              mutate {
                                id => "suricata_dest_as_from_as_org_asn"
                                add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][as_org]} (%{[metadata][geoip_dest][asn]})" }
                              }
                            } else {
                              mutate {
                                id => "suricata_dest_as_from_as_org"
                                add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][as_org]}" }
                              }
                            }
                          } else if [metadata][geoip_dest][asn] {
                            mutate {
                              id => "suricata_dest_as_from_asn"
                              add_field => { "[dest_autonomous_system]" => "%{[metadata][geoip_dest][asn]}" }
                            }
                          } else {
                            mutate {
                              add_field => { "[dest_autonomous_system]" => "public" }
                            }
                          }
                          mutate {
                            id => "suricata_set_dest_asn"
                            rename => { "[metadata][geoip_dest][asn]" => "[dest_asn]" }
                          }
                        } else {
                          mutate {
                            add_field => { "[dest_autonomous_system]" => "public" }
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      } else {
                        mutate {
                          id => "suricata_no_dest_asn_lookup"
                          add_field => { "[dest_autonomous_system]" => "public" }
                        }
                      }
                      mutate {
                        add_field => {
                          "[autonomous_system]" => "%{[dest_autonomous_system]}"
                        }
                      }

                    # Lookup destination IP reputation.
                      translate {
                        id => "suricata_public_dest_rep_label"
                        dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/ip_rep_basic.yml"
                        field => "[dest_ip]"
                        destination => "[@metadata][dest_rep_label]"
                      }
                      # Parse the IP reputation lable into tags.
                      if [@metadata][dest_rep_label] {
                        ruby {
                          id => "suricata_public_dest_rep_tags"
                          init => "
                            require 'csv'
                          "
                          code => "
                            event.set('[dest_rep_tags]', event.get('[@metadata][dest_rep_label]').parse_csv)
                          "
                        }
                      }
                  }
              }

              if [src_ip] {
                # Check if source IP address is private.
                  cidr {
                    id => "suricata_cidr_src_ip"
                    address => [ "%{[src_ip]}" ]
                    network => [ "0.0.0.0/32", "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7", "127.0.0.0/8", "::1/128", "169.254.0.0/16", "fe80::/10", "224.0.0.0/4", "ff00::/8", "255.255.255.255/32", "::" ]
                    add_field => { "[src_autonomous_system]" => "private" }
                  }

                # Check to see if src_autonomous_system exists. If it doesn't the src_ip didn't match a private address space and locality must be public.
                  if ![src_autonomous_system] {
                    mutate {
                      id => "suricata_src_ip_public"
                      replace => { "[traffic_locality]" => "public" }
                    }

                    # If enabled lookup source GeoIP location.
                      if [@metadata][geoip_lookup] == "true" {
                        geoip {
                          id => "suricata_geoip_src_city"
                          source => "[src_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-City.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_src]"
                          fields => [ "city_name", "country_name", "location" ]
                        }
                        if "_geoip_lookup_failure" not in [tags] {
                          mutate {
                            rename => {
                              "[metadata][geoip_src][city_name]" => "[src_city]"
                              "[metadata][geoip_src][country_name]" => "[src_country]"
                              "[metadata][geoip_src][location]" => "[src_geo_location]"
                            }
                          }
                          if [src_city] {
                            mutate {
                              add_field => { "[city]" => "%{[src_city]}" }
                            }
                          }
                          if [src_country] {
                            mutate {
                              add_field => { "[country]" => "%{[src_country]}" }
                            }
                          }
                        }
                      }

                    # If enabled lookup the source Autonomous System.
                      if [@metadata][asn_lookup] == "true" {
                        geoip {
                          id => "suricata_geoip_src_asn"
                          source => "[src_ip]"
                          database => "${SYNLITE_SURICATA_GEOIP_DB_PATH:/etc/logstash/synlite_suricata/geoipdbs}/GeoLite2-ASN.mmdb"
                          cache_size => "${SYNLITE_SURICATA_GEOIP_CACHE_SIZE:8192}"
                          target => "[metadata][geoip_src]"
                        }
                        # Populate src_autonomous_system.
                        if "_geoip_lookup_failure" not in [tags] {
                          if [metadata][geoip_src][as_org] {
                            if [metadata][geoip_src][asn] {
                              mutate {
                                id => "suricata_src_as_from_as_org_asn"
                                add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][as_org]} (%{[metadata][geoip_src][asn]})" }
                              }
                            } else {
                              mutate {
                                id => "suricata_src_as_from_as_org"
                                add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][as_org]}" }
                              }
                            }
                          } else if [metadata][geoip_src][asn] {
                            mutate {
                              id => "suricata_src_as_from_asn"
                              add_field => { "[src_autonomous_system]" => "%{[metadata][geoip_src][asn]}" }
                            }
                          } else {
                            mutate {
                              add_field => { "[src_autonomous_system]" => "public" }
                            }
                          }
                          mutate {
                            id => "suricata_set_src_asn"
                            rename => { "[metadata][geoip_src][asn]" => "[src_asn]" }
                          }
                        } else {
                          mutate {
                            add_field => { "[src_autonomous_system]" => "public" }
                            remove_tag => [ "_geoip_lookup_failure" ]
                          }
                        }
                      } else {
                        mutate {
                          id => "suricata_no_src_asn_lookup"
                          add_field => { "[src_autonomous_system]" => "public" }
                        }
                      }
                      mutate {
                        add_field => {
                          "[autonomous_system]" => "%{[src_autonomous_system]}"
                        }
                      }
                    
                    # Lookup source IP reputation.
                      translate {
                        id => "suricata_public_src_rep_label"
                        dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/ip_rep_basic.yml"
                        field => "[src_ip]"
                        destination => "[@metadata][src_rep_label]"
                      }
                      # Parse the IP reputation lable into tags.
                      if [@metadata][src_rep_label] {
                        ruby {
                          id => "suricata_public_src_rep_tags"
                          init => "
                            require 'csv'
                          "
                          code => "
                            event.set('[src_rep_tags]', event.get('[@metadata][src_rep_label]').parse_csv)
                          "
                        }
                      }
                  }
              }

              # Cleanup any GeoIP lookup failure tag.
                if "_geoip_lookup_failure" in [tags] {
                  mutate {
                    id => "suricata_cleanup_geoip_fail_tag"
                    remove_tag => [ "_geoip_lookup_failure" ]
                  }
                }

              # Merge reputation tags.
                ruby {
                  id => "suricata_merge_rep_tags"
                  init => "
                    require 'csv'
                  "
                  code => "
                    src_tags = event.get('[@metadata][src_rep_label]')
                    dest_tags = event.get('[@metadata][dest_rep_label]')

                    if (src_tags)
                      rep_tags = src_tags
                      if (dest_tags)
                        rep_tags = rep_tags << ',' << dest_tags
                      end
                    else (dest_tags)
                      rep_tags = dest_tags
                    end

                    if (rep_tags)
                      event.set('[rep_tags]', rep_tags.parse_csv )
                    end
                  "
                }
            }
          
          # IP traffic processing.
            if [proto] {
              # lookup IANA service name for source and destination ports.
                if [proto] == "TCP" {
                  if [src_port] {
                    translate {
                      id => "suricata_translate_src_port_name_tcp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_tcp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      id => "suricata_translate_dest_port_name_tcp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_tcp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "UDP" {
                  if [src_port] {
                    translate {
                      id => "suricata_translate_src_port_name_udp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_udp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      id => "suricata_translate_dest_port_name_udp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_udp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "SCTP" {
                  if [src_port] {
                    translate {
                      id => "suricata_translate_src_port_name_sctp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_sctp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      id => "suricata_translate_dest_port_name_sctp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_sctp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else if [proto] == "DCCP" {
                  if [src_port] {
                    translate {
                      id => "suricata_translate_src_port_name_dccp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_dccp.yml"
                      field => "[src_port]"
                      destination => "[src_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                  if [dest_port] {
                    translate {
                      id => "suricata_translate_dest_port_name_dccp"
                      dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/iana_service_names_dccp.yml"
                      field => "[dest_port]"
                      destination => "[dest_port_name]"
                      fallback => "__UNKNOWN"
                    }
                  }
                } else {
                  mutate {
                    add_field => {
                      "[src_port_name]" => "__UNKNOWN"
                      "[dest_port_name]" => "__UNKNOWN"
                    }
                  }
                }

              # Ensure port numbers are integers.
                mutate {
                  id => "suricata_convert_ports_to_int"
                  convert => {
                    "[src_port]" => "integer"
                    "[dest_port]" => "integer"
                  }
                }

              # Determine client and server from source and destination ports.
                if [dest_port] and [src_port] {
                  if [src_port_name] == "__UNKNOWN" {
                    if [dest_port_name] == "__UNKNOWN" {
                      if [dest_port] <= [src_port] {
                        mutate {
                          id => "suricata_srcUn_destUn_destIsSrv"
                          add_field => { "[@metadata][isServer]" => "dest" }
                        }
                      } else {
                        mutate {
                          id => "suricata_srcUn_destUn_srcIsSrv"
                          add_field => { "[@metadata][isServer]" => "src" }
                        }
                      }
                    } else {
                      mutate {
                        id => "suricata_srcUn_destKn_destIsSrv"
                        add_field => { "[@metadata][isServer]" => "dest" }
                      }
                    }
                  } else {
                    if [dest_port_name] == "__UNKNOWN" {
                      mutate {
                        id => "suricata_srcKn_destUn_srcIsSrv"
                        add_field => { "[@metadata][isServer]" => "src" }
                      }
                    } else {
                      if [dest_port] <= [src_port] {
                        mutate {
                          id => "suricata_srcKn_destKn_destIsSrv"
                          add_field => { "[@metadata][isServer]" => "dest" }
                        }
                      } else {
                        mutate {
                          id => "suricata_srcKn_destKn_srcIsSrv"
                          add_field => { "[@metadata][isServer]" => "src" }
                        }
                      }
                    }
                  }
                }

              # Set final value of port name fields.
                if [src_port_name] {
                  if [src_port_name] == "__UNKNOWN" {
                    if [src_port] {
                      mutate {
                        id => "suricata_src_port_name_unknown"
                        replace => { "[src_port_name]" => "%{[proto]}/%{[src_port]}" }
                      }
                    } else {
                      mutate {
                        id => "suricata_src_port_name_unknown_port_0"
                        replace => { "[src_port_name]" => "%{[proto]}/0" }
                      }
                    }
                  } else {
                    mutate {
                      id => "suricata_src_port_name_prepend_src_port"
                      replace => { "[src_port_name]" => "%{[src_port_name]} (%{[proto]}/%{[src_port]})" }
                    }
                  }
                }
                if [dest_port_name] {
                  if [dest_port_name] == "__UNKNOWN" {
                    if [dest_port] {
                      mutate {
                        id => "suricata_dest_port_name_unknown"
                        replace => { "[dest_port_name]" => "%{[proto]}/%{[dest_port]}" }
                      }
                    } else {
                      mutate {
                        id => "suricata_dest_port_name_unknown_port_0"
                        replace => { "[dest_port_name]" => "%{[proto]}/0" }
                      }
                    }
                  } else {
                    mutate {
                      id => "suricata_dest_port_name_prepend_dest_port"
                      replace => { "[dest_port_name]" => "%{[dest_port_name]} (%{[proto]}/%{[dest_port]})" }
                    }
                  }
                }

              # Set client, server and service fields.
                if [@metadata][isServer] == "dest" {
                  mutate {
                    id => "suricata_destIsSrv_add_fields"
                    add_field => {
                      "[server_ip]" => "%{[dest_ip]}"
                      "[server_hostname]" => "%{[dest_hostname]}"
                      "[server_autonomous_system]" => "%{[dest_autonomous_system]}"
                      "[service_port]" => "%{[dest_port]}"
                      "[service_name]" => "%{[dest_port_name]}"
                      "[client_ip]" => "%{[src_ip]}"
                      "[client_hostname]" => "%{[src_hostname]}"
                      "[client_autonomous_system]" => "%{[src_autonomous_system]}"
                    }
                  }
                  if [dest_autonomous_system] != "private" {
                    if [dest_city] {
                      mutate {
                        id => "suricata_destIsSrv_add_dest_city"
                        add_field => { "[server_city]" => "%{[dest_city]}" }
                      }
                    }
                    if [dest_country] {
                      mutate {
                        id => "suricata_destIsSrv_add_dest_country"
                        add_field => { "[server_country]" => "%{[dest_country]}" }
                      }
                    }
                    if [dest_geo_location] {
                      mutate {
                        id => "suricata_destIsSrv_add_dest_geo_location"
                        add_field => { "[server_geo_location]" => "%{[dest_geo_location][lat]},%{[dest_geo_location][lon]}" }
                      }
                    }
                    if [dest_asn] {
                      mutate {
                        id => "suricata_destIsSrv_add_dest_asn"
                        add_field => { "[server_asn]" => "%{[dest_asn]}" }
                      }
                    }
                  }
                  if [src_autonomous_system] != "private" {
                    if [src_city] {
                      mutate {
                        id => "suricata_destIsSrv_add_src_src_city"
                        add_field => { "[client_city]]" => "%{[src_city]}" }
                      }
                    }
                    if [src_country] {
                      mutate {
                        id => "suricata_destIsSrv_add_src_country"
                        add_field => { "[client_country]" => "%{[src_country]}" }
                      }
                    }
                    if [src_geo_location] {
                      mutate {
                        id => "suricata_destIsSrv_add_src_geo_location"
                        add_field => { "[client_geo_location]" => "%{[src_geo_location][lat]},%{[src_geo_location][lon]}" }
                      }
                    }
                    if [src_asn] {
                      mutate {
                        id => "suricata_destIsSrv_add_src_asn"
                        add_field => { "[client_asn]" => "%{[src_asn]}" }
                      }
                    }
                  }
                } else if [@metadata][isServer] == "src" {
                  mutate {
                    id => "suricata_srcIsSrv_add_fields"
                    add_field => {
                      "[server_ip]" => "%{[src_ip]}"
                      "[server_hostname]" => "%{[src_hostname]}"
                      "[server_autonomous_system]" => "%{[src_autonomous_system]}"
                      "[service_port]" => "%{[src_port]}"
                      "[service_name]" => "%{[src_port_name]}"
                      "[client_ip]" => "%{[dest_ip]}"
                      "[client_hostname]" => "%{[dest_hostname]}"
                      "[client_autonomous_system]" => "%{[dest_autonomous_system]}"
                    }
                  }
                  if [dest_autonomous_system] != "private" {
                    if [dest_city] {
                      mutate {
                        id => "suricata_srcIsSrv_add_dest_city"
                        add_field => { "[client_city]]" => "%{[dest_city]}" }
                      }
                    }
                    if [dest_country] {
                      mutate {
                        id => "suricata_srcIsSrv_add_dest_country"
                        add_field => { "[client_country]" => "%{[dest_country]}" }
                      }
                    }
                    if [dest_geo_location] {
                      mutate {
                        id => "suricata_srcIsSrv_add_dest_geo_location"
                        add_field => { "[client_geo_location]" => "%{[dest_geo_location][lat]},%{[dest_geo_location][lon]}" }
                      }
                    }
                    if [dest_asn] {
                      mutate {
                        id => "suricata_srcIsSrv_add_dest_asn"
                        add_field => { "[client_asn]" => "%{[dest_asn]}" }
                      }
                    }
                  }
                  if [src_autonomous_system] != "private" {
                    if [src_city] {
                      mutate {
                        id => "suricata_srcIsSrv_add_src_autonomous_system"
                        add_field => { "[server_city]]" => "%{[src_city]}" }
                      }
                    }
                    if [src_country] {
                      mutate {
                        id => "suricata_srcIsSrv_add_src_country"
                        add_field => { "[server_country]" => "%{[src_country]}" }
                      }
                    }
                    if [src_geo_location] {
                      mutate {
                        id => "suricata_srcIsSrv_add_src_geo_location"
                        add_field => { "[server_geo_location]" => "%{[src_geo_location][lat]},%{[src_geo_location][lon]}" }
                      }
                    }
                    if [src_asn] {
                      mutate {
                        id => "suricata_srcIsSrv_add_src_asn"
                        add_field => { "[server_asn]" => "%{[src_asn]}" }
                      }
                    }
                  }
                }
            }

          # Populate flow.bytes
            if [flow][bytes_toclient] {
              if [flow][bytes_toserver] {
                ruby {
                  code => "
                    event.set( '[flow][bytes]', event.get('[flow][bytes_toclient]').to_i + event.get('[flow][bytes_toserver]').to_i )
                  "
                }
              } else {
                mutate {
                  rename => { "[flow][bytes]" => "%{[flow][bytes_toclient]}" }
                }
              }
            } else if [flow][bytes_toserver] {
              mutate {
                rename => { "[flow][bytes]" => "%{[flow][bytes_toserver]}" }
              }
            }
            if [flow][bytes] {
              mutate {
                convert => { "[flow][bytes]" => "integer" }
              }
            }

          # Populate flow.pkts
            if [flow][pkts_toclient] {
              if [flow][pkts_toserver] {
                ruby {
                  code => "
                    event.set( '[flow][pkts]', event.get('[flow][pkts_toclient]').to_i + event.get('[flow][pkts_toserver]').to_i )
                  "
                }
              } else {
                mutate {
                  rename => { "[flow][pkts]" => "%{[flow][pkts_toclient]}" }
                }
              }
            } else if [flow][pkts_toserver] {
              mutate {
                rename => { "[flow][pkts]" => "%{[flow][pkts_toserver]}" }
              }
            }
            if [flow][pkts] {
              mutate {
                convert => { "[flow][pkts]" => "integer" }
              }
            }
          # Process TCP flags.
            if [tcp][tcp_flags] {
              if [tcp][ack] {
                mutate {
                  add_field => { "[tcp_flags]" => "ACK" }
                }
              }
              if [tcp][cwr] {
                mutate {
                  add_field => { "[tcp_flags]" => "CWR" }
                }
              }
              if [tcp][ece] {
                mutate {
                  add_field => { "[tcp_flags]" => "ECE" }
                }
              }
              if [tcp][fin] {
                mutate {
                  add_field => { "[tcp_flags]" => "FIN" }
                }
              }
              if [tcp][psh] {
                mutate {
                  add_field => { "[tcp_flags]" => "PSH" }
                }
              }
              if [tcp][rst] {
                mutate {
                  add_field => { "[tcp_flags]" => "RST" }
                }
              }
              if [tcp][syn] {
                mutate {
                  add_field => { "[tcp_flags]" => "SYN" }
                }
              }
              if [tcp][urg] {
                mutate {
                  add_field => { "[tcp_flags]" => "URG" }
                }
              }

              mutate {
                remove_field => [ "[tcp][ack]", "[tcp][cwr]", "[tcp][ece]", "[tcp][fin]", "[tcp][psh]", "[tcp][rst]", "[tcp][syn]", "[tcp][urg]" ]
              }
            } else {
              mutate {
                replace => { "[tcp_flags]" => "none" }
              }
            }

          # Set log.severity
            if [alert][severity] {
              translate {
                field => "[alert][severity]"
                destination => "[log][severity]"
                dictionary => {
                  "1" => "alert"
                  "2" => "critical"
                  "3" => "warning"
                  "4" => "notice"
                }
                fallback => "warning"
              }
            } else {
              mutate {
                replace => { "[log][severity]" => "informational" }
              }
            }

          # Populate alert.cve.
            if [alert][signature_id] {
              translate {
                id => "suricata_cve"
                dictionary_path => "${SYNLITE_SURICATA_DICT_PATH:/etc/logstash/synlite_suricata/dictionaries}/suricata_cve.yml"
                field => "[alert][signature_id]"
                destination => "[alert][cve]"
              }
            }

          # Cleanup metadata object.
            mutate {
              id => "suricata_remove_metadata"
              remove_field => [ "[metadata]" ]
            }
        }
      }
  }
}
